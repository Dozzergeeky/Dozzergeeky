'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const Parser = require('web-tree-sitter');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const Parser__default = /*#__PURE__*/_interopDefaultLegacy(Parser);

function createTransformer(options) {
    return { encode, decode };
    function encode(tree) {
        let offset = 0;
        let attributes = {};
        const richtext = { ops: [] };
        const sourcemap = [];
        processNode(tree.rootNode);
        return [richtext, sourcemap];
        function processNode(node) {
            if (options.shouldIgnoreSubtree(node))
                return; // stop processing sub-tree
            const previousAttributes = attributes;
            attributes = { ...previousAttributes, ...options.getAttributesFor(node, { ...attributes }) };
            options.processNode(node, insert);
            node.children.forEach(processNode);
            if (options.isBlockNode(node) && !hasTrailingNewline())
                insert('\n');
            attributes = previousAttributes;
        }
        function insert(text, node, skip = 0) {
            richtext.ops.push({
                insert: text,
                attributes: text === '\n' ? pickBlockAttributes(attributes) : pickInlineAttributes(attributes),
            });
            if (node != null)
                sourcemap.push([node.startIndex + skip, offset, text.length]);
            else if (sourcemap.length > 0) {
                const last = sourcemap[sourcemap.length - 1];
                sourcemap.push([last[0] + last[2], offset, 0]);
            }
            else {
                sourcemap.push([0, offset, 0]);
            }
            offset += text.length;
        }
        function hasTrailingNewline() {
            return richtext.ops.length > 0 && String(richtext.ops[richtext.ops.length - 1].insert).endsWith('\n');
        }
    }
    function decode(text) {
        var _a, _b, _c, _d;
        const ops = text.ops.reduce((ops, op) => {
            if (ops.length === 0 || op.insert === '\n') {
                ops.push(op);
            }
            else {
                const last = ops[ops.length - 1];
                if (typeof last.insert === 'string' &&
                    typeof op.insert === 'string' &&
                    last.insert !== '\n' &&
                    sameAttributes(last.attributes, op.attributes)) {
                    last.insert += op.insert;
                }
                else {
                    ops.push(op);
                }
            }
            return ops;
        }, []);
        const root = { type: 'block', childNodes: [], attributes: {}, value: {} };
        function findParent(node, attributes) {
            if (node === root) {
                const parent = { type: 'inline', attributes, value: attributes, childNodes: [], parent: node };
                root.childNodes.push(parent);
                return parent;
            }
            const diff = diffAttributes(node.attributes, attributes);
            if (diff.removed.length == 0 && diff.added.length === 0)
                return node;
            if (diff.removed.length === 0) {
                const value = {};
                diff.added.forEach((key) => {
                    value[key] = attributes[key];
                });
                const parent = { type: 'inline', attributes, value, childNodes: [], parent: node };
                node.childNodes.push(parent);
                return parent;
            }
            if (node.parent == null)
                throw new Error('Unexpected');
            return findParent(node.parent, attributes);
        }
        let current = root;
        const leaves = [];
        for (let i = 0; i < ops.length; i += 1) {
            const op = ops[i];
            if (op.insert === '\n' && i > 0) {
                let j = i;
                for (; j >= 0; --j) {
                    if (((_a = ops[j - 1]) === null || _a === void 0 ? void 0 : _a.insert) === '\n')
                        break;
                }
                const target = commonAncestor(leaves.find((leave) => leave.op === ops[j]), leaves[leaves.length - 1]);
                const parent = target.parent;
                const node = {
                    type: 'block',
                    attributes: (_b = op.attributes) !== null && _b !== void 0 ? _b : {},
                    value: (_c = op.attributes) !== null && _c !== void 0 ? _c : {},
                    childNodes: [target],
                    parent: parent,
                };
                const index = parent.childNodes.indexOf(target);
                parent.childNodes.splice(index, 1);
                parent.childNodes.push(node);
                target.parent = node;
            }
            else {
                const node = { type: '#text', op };
                leaves.push(node);
                current = findParent(current, (_d = op.attributes) !== null && _d !== void 0 ? _d : {});
                current.childNodes.push(node);
            }
        }
        return processNode(root);
        function processNode(node) {
            if (node.type === '#text')
                return options.stringify(node, '');
            return options.stringify(node, node.childNodes.map((node) => processNode(node)).join(''));
        }
    }
}
function commonAncestor(a, b) {
    const pa = pathFromRoot(a);
    const pb = pathFromRoot(b);
    const n = Math.min(pa.length, pb.length);
    for (let i = 0; i < n; ++i) {
        if (pa[i] !== pb[i])
            return getEl(pa[i - 1]);
    }
    throw new Error('No commont ancestor');
    function getEl(node) {
        if (node.type === '#text')
            return node.parent;
        return node;
    }
}
function pathFromRoot(node) {
    const path = [];
    let current = node;
    while (current != null) {
        path.push(current);
        current = current.parent;
    }
    return path.reverse();
}
function sameAttributes(a, b) {
    if (a === b)
        return true;
    if (a == null || b == null)
        return false;
    if (Object.keys(a).length !== Object.keys(b).length)
        return false;
    return Object.keys(a).every((key) => a[key] === b[key]);
}
function diffAttributes(target, source) {
    if (target == null && source == null)
        return { added: [], removed: [] };
    else if (target == null && source != null)
        return { added: Object.keys(source), removed: [] };
    else if (target != null && source == null)
        return { added: [], removed: Object.keys(target) };
    else if (target != null && source != null) {
        const added = [];
        const removed = [];
        for (const key of Object.keys(target)) {
            if (!(key in source)) {
                removed.push(key);
            }
            else if (source[key] !== target[key]) {
                added.push(key);
                removed.push(key);
            }
        }
        for (const key of Object.keys(source)) {
            if (!(key in target)) {
                added.push(key);
            }
        }
        return { added, removed };
    }
    return { added: [], removed: [] };
}
function pickBlockAttributes(attributes) {
    const picked = {};
    for (const key of ['header', 'list', 'indent']) {
        if (key in attributes) {
            // @ts-expect-error
            picked[key] = attributes[key];
        }
    }
    return picked;
}
function pickInlineAttributes(attributes) {
    const picked = {};
    for (const key of ['bold', 'italic', 'underline', 'code', 'link']) {
        if (key in attributes) {
            // @ts-expect-error
            picked[key] = attributes[key];
        }
    }
    return picked;
}

const IGNORED_NODES$1 = new Set([
    "'",
    '/>',
    '"',
    '<',
    '<!',
    '</',
    '=',
    '>',
    'attribute',
    'attribute_name',
    'attribute_value',
    'comment',
    'doctype',
    'end_tag',
    'erroneous_end_tag',
    'erroneous_end_tag_name',
    'fragment',
    'quoted_attribute_value',
    'raw_text',
    'script_element',
    'self_closing_tag',
    'start_tag',
    'style_element',
    'tag_name',
]);
const BLOCK_NODES$1 = new Set(['element']);
const html = createTransformer({
    isBlockNode(node) {
        return BLOCK_NODES$1.has(node.type);
    },
    shouldIgnoreSubtree(node) {
        return IGNORED_NODES$1.has(node.type);
    },
    getAttributesFor(node) {
        switch (node.type) {
            case 'strong_emphasis':
                return { bold: true };
            case 'emphasis':
                return { italic: true };
            case 'code_span':
                return { code: true };
            case 'atx_heading':
                if (node.firstChild != null) {
                    // atx_h[1-6]_marker
                    return { header: parseInt(node.firstChild.type.substring(5, 6), 10) };
                }
                return {};
            default:
                return {};
        }
    },
    stringify(node, content) {
        if (node.type === '#text') {
            if (typeof node.op === 'string')
                return node.op;
            return '\n';
        }
        return toHTML(content, node.value);
        function toHTML(text, attributes) {
            if (attributes.bold)
                return `<b>${text}</b>`;
            if (attributes.italic)
                return `<i>${text}</i>`;
            if (attributes.code)
                return `<code>${text}</code>`;
            if (attributes.linebreak)
                return `<br />`;
            if (attributes.link)
                return `<a href=${JSON.stringify(attributes.link)}>${text}</a>`;
            if (attributes.header)
                return `<h${attributes.header}>${content}</h${attributes.header}>`;
            return text;
        }
    },
    processNode(node, insert) {
        if (node.type === 'text') {
            insert(node.text, node);
        }
    },
});

const IGNORED_NODES = new Set([
    'atx_h1_marker',
    'atx_h2_marker',
    'atx_h3_marker',
    'atx_h4_marker',
    'atx_h5_marker',
    'atx_h6_marker',
    'block_quote',
    'code_fence_content',
    'fenced_code_block',
    'html_atrribute',
    'html_attribute_key',
    'html_attribute_value',
    'html_cdata_section',
    'html_close_tag',
    'html_comment',
    'html_declaration_name',
    'html_declaration',
    'html_open_tag',
    'html_processing_instruction',
    'html_self_closing_tag',
    'html_tag_name',
    'link_destination',
    'link_reference_definition',
    'list_marker',
    'setext_h1_underline',
    'setext_h2_underline',
    'table_cell',
    'table_column_alignment',
    'table_data_row',
    'table_delimiter_row',
    'table_header_row',
    'table',
    'task_list_item_marker',
]);
const BLOCK_NODES = new Set([
    'document',
    'atx_heading',
    'setext_heading',
    'task_list_item',
    'html_block',
    'image_description',
    'indented_code_block',
    'list_item',
    'paragraph',
    'thematic_break',
    'tight_list',
]);
const markdown = createTransformer({
    isBlockNode(node) {
        return BLOCK_NODES.has(node.type);
    },
    shouldIgnoreSubtree(node) {
        return IGNORED_NODES.has(node.type);
    },
    getAttributesFor(node, attributes) {
        var _a, _b, _c, _d, _e, _f;
        switch (node.type) {
            case 'strong_emphasis':
                return { bold: true };
            case 'emphasis':
                return { italic: true };
            case 'code_span':
                return { code: true };
            case 'atx_heading':
                if (node.firstChild != null) {
                    // atx_h[1-6]_marker
                    return { header: parseInt(node.firstChild.type.substring(5, 6), 10) };
                }
                return {};
            case 'setext_heading':
                if (node.lastNamedChild != null) {
                    // setext_h[1-2]_underline
                    return {
                        header: parseInt(node.lastNamedChild.type.substring('setext_h'.length, 'setext_h'.length + 1), 10),
                    };
                }
                return {};
            case 'link':
                if (((_a = node.lastNamedChild) === null || _a === void 0 ? void 0 : _a.type) === 'link_destination') {
                    return {
                        link: (_c = (_b = node.lastNamedChild.firstNamedChild) === null || _b === void 0 ? void 0 : _b.text) !== null && _c !== void 0 ? _c : '',
                    };
                }
                return { link: '' };
            case 'tight_list':
                return {
                    list: /[0-9]/.test((_f = (_e = (_d = node.firstNamedChild) === null || _d === void 0 ? void 0 : _d.firstNamedChild) === null || _e === void 0 ? void 0 : _e.text) !== null && _f !== void 0 ? _f : '') ? 'number' : 'bullet',
                    indent: attributes.indent != null ? attributes.indent + 1 : 1,
                };
            default:
                return {};
        }
    },
    stringify(node, content) {
        if (node.type === '#text') {
            if (typeof node.op.insert === 'string')
                return node.op.insert;
            return '\n';
        }
        return toMarkdown(content, node.value);
    },
    processNode(node, insert) {
        var _a, _b, _c;
        if (node.type === 'text') {
            if (((_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.type) === 'atx_heading') {
                insert(node.text.slice(1), node, 1);
            }
            else if (((_c = node.parent) === null || _c === void 0 ? void 0 : _c.type) === 'paragraph' && node.text.startsWith(': ')) {
                insert(node.text.slice(2), node, 2); // #255 - Definition Lists
            }
            else
                insert(node.text, node);
        }
        else if (node.type === 'line_break' || node.type === 'hard_line_break') {
            insert('\n', node);
        }
        else if (node.type === 'soft_line_break') {
            insert(' ', node);
        }
    },
});
function toMarkdown(text, attributes) {
    if (attributes == null)
        return text;
    if (attributes.bold)
        return `**${text}**`;
    if (attributes.italic)
        return `_${text}_`;
    if (attributes.code)
        return '`' + text + '`';
    if (attributes.link)
        return `[${text}](${attributes.link})`;
    if (attributes.list && attributes.indent != null)
        return `${'  '.repeat(attributes.indent - 1)}${attributes.list === 'number' ? '1. ' : '- '}${text}\n`;
    if (attributes.header)
        return '#'.repeat(attributes.header) + ' ' + text + '\n';
    if (attributes['code-block'])
        return '```\n' + text + '\n```\n';
    return text;
}

const parsers = new Map();
const parsersPending = new Map();
async function createParser(language) {
    const previous = parsers.get(language);
    if (previous != null)
        return previous;
    const parser = createParserInner();
    parsersPending.set(language, parser);
    return await parser;
    async function createParserInner() {
        await Parser__default["default"].init();
        const parser = new Parser__default["default"]();
        parser.setLanguage(await Parser__default["default"].Language.load(getLanguageFile()));
        parsers.set(language, parser);
        parsersPending.delete(language);
        return parser;
    }
    function getLanguageFile() {
        var _a;
        if (typeof process !== 'undefined' && ((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node) != null) {
            if (process.env.NODE_ENV === 'test') {
                return require.resolve(`../dist/tree-sitter-${language}.wasm`);
            }
            return require.resolve(`./tree-sitter-${language}.wasm`);
        }
        return `tree-sitter-${language}.wasm`;
    }
}
const transformers = { html, markdown };

exports.createParser = createParser;
exports.transformers = transformers;
//# sourceMappingURL=index.cjs.map
