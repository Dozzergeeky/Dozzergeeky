'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const node = require('vscode-languageserver/node');
require('reflect-metadata');
const inversify = require('inversify');
const vscodeLanguageserverTextdocument = require('vscode-languageserver-textdocument');
const grammarlyRichtextEncoder = require('grammarly-richtext-encoder');
const sdk = require('@grammarly/sdk');
const node_fs = require('node:fs');
const node_path = require('node:path');
const node_os = require('node:os');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    const n = Object.create(null);
    if (e) {
        for (const k in e) {
            if (k !== 'default') {
                const d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        }
    }
    n["default"] = e;
    return Object.freeze(n);
}

// @ts-nocheck
if (typeof global !== 'undefined' && typeof global.fetch === 'undefined') {
    (async () => {
        const { default: fetch, Request, Response, Headers } = await getNodeFetch();
        global.fetch = fetch;
        global.Request = Request;
        global.Response = Response;
        global.Headers = Headers;
    })();
    async function getNodeFetch() {
        try {
            return await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('node-fetch')); });
        }
        catch {
            return require('node-fetch');
        }
    }
}

const GRAMMARLY_SDK = Symbol('GrammarlySDK');
const TEXT_DOCUMENTS_FACTORY = Symbol('TextDocuments');
const CLIENT = Symbol('ClientCapabilities');
const CLIENT_INFO = Symbol('ClientInfo');
const CLIENT_INITIALIZATION_OPTIONS = Symbol('ClientInitializationOptions');
const SERVER = Symbol('ServerCapabilities');
const CONNECTION = Symbol('Connection');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

var _ConfigurationService_connection;
let ConfigurationService = class ConfigurationService {
    constructor(connection) {
        _ConfigurationService_connection.set(this, void 0);
        __classPrivateFieldSet(this, _ConfigurationService_connection, connection, "f");
    }
    register() {
        return { dispose() { } };
    }
    async getSettings() {
        var _a;
        const result = await __classPrivateFieldGet(this, _ConfigurationService_connection, "f").workspace.getConfiguration('grammarly');
        return (_a = result === null || result === void 0 ? void 0 : result.config) !== null && _a !== void 0 ? _a : {};
    }
    async getDocumentSettings(uri) {
        var _a;
        const result = await Promise.race([
            __classPrivateFieldGet(this, _ConfigurationService_connection, "f").workspace.getConfiguration({ scopeUri: uri, section: 'grammarly' }),
            new Promise((resolve) => setTimeout(resolve, 1000, {})),
        ]);
        return (_a = result === null || result === void 0 ? void 0 : result.config) !== null && _a !== void 0 ? _a : {};
    }
};
_ConfigurationService_connection = new WeakMap();
ConfigurationService = __decorate([
    inversify.injectable(),
    __param(0, inversify.inject(CONNECTION)),
    __metadata("design:paramtypes", [Object])
], ConfigurationService);

var _DocumentService_config, _DocumentService_connection, _DocumentService_capabilities, _DocumentService_documents, _DocumentService_onDocumentOpenCbs, _DocumentService_onDocumentCloseCbs, _GrammarlyDocument_instances, _GrammarlyDocument_context, _GrammarlyDocument_createTree, _GrammarlyDocument_sync;
let DocumentService = class DocumentService {
    constructor(connection, capabilities, sdk, createTextDocuments, options, config) {
        _DocumentService_config.set(this, void 0);
        _DocumentService_connection.set(this, void 0);
        _DocumentService_capabilities.set(this, void 0);
        _DocumentService_documents.set(this, void 0);
        _DocumentService_onDocumentOpenCbs.set(this, []);
        _DocumentService_onDocumentCloseCbs.set(this, []);
        __classPrivateFieldSet(this, _DocumentService_connection, connection, "f");
        __classPrivateFieldSet(this, _DocumentService_capabilities, capabilities, "f");
        __classPrivateFieldSet(this, _DocumentService_config, config, "f");
        __classPrivateFieldSet(this, _DocumentService_documents, createTextDocuments({
            create(uri, languageId, version, content) {
                const document = new GrammarlyDocument(vscodeLanguageserverTextdocument.TextDocument.create(uri, languageId, version, content), async () => {
                    const options = await config.getDocumentSettings(uri);
                    connection.console.log(`create text checking session for "${uri}" with ${JSON.stringify(options, null, 2)} `);
                    return sdk.withText({ ops: [] }, options);
                });
                if (options.startTextCheckInPausedState === true)
                    document.pause();
                return document;
            },
            update(document, changes, version) {
                document.update(changes, version);
                return document;
            },
        }), "f");
    }
    register() {
        __classPrivateFieldGet(this, _DocumentService_capabilities, "f").textDocumentSync = {
            openClose: true,
            change: 2,
        };
        __classPrivateFieldGet(this, _DocumentService_documents, "f").listen(__classPrivateFieldGet(this, _DocumentService_connection, "f"));
        __classPrivateFieldGet(this, _DocumentService_connection, "f").onRequest('$/getDocumentStatus', async ([uri]) => {
            const document = __classPrivateFieldGet(this, _DocumentService_documents, "f").get(uri);
            if (document == null)
                return null;
            if (document.isPaused)
                return 'paused';
            await document.isReady();
            return document.session.status;
        });
        __classPrivateFieldGet(this, _DocumentService_connection, "f").onRequest('$/dismissSuggestion', async ([options]) => {
            const document = __classPrivateFieldGet(this, _DocumentService_documents, "f").get(options.uri);
            if (document == null)
                return;
            await document.session.dismissSuggestion({ suggestionId: options.suggestionId });
        });
        __classPrivateFieldGet(this, _DocumentService_connection, "f").onDidChangeConfiguration(async () => {
            await Promise.all(__classPrivateFieldGet(this, _DocumentService_documents, "f").all().map(async (document) => {
                await document.isReady();
                document.session.setConfig(await __classPrivateFieldGet(this, _DocumentService_config, "f").getDocumentSettings(document.original.uri));
            }));
        });
        const disposables = [
            __classPrivateFieldGet(this, _DocumentService_documents, "f").onDidOpen(async ({ document }) => {
                __classPrivateFieldGet(this, _DocumentService_connection, "f").console.log('open ' + document.original.uri);
                await document.isReady();
                __classPrivateFieldGet(this, _DocumentService_connection, "f").console.log('ready ' + document.original.uri);
                __classPrivateFieldGet(this, _DocumentService_connection, "f").sendNotification('$/grammarlyCheckingStatus', {
                    uri: document.original.uri,
                    status: document.session.status,
                });
                __classPrivateFieldGet(this, _DocumentService_onDocumentOpenCbs, "f").forEach((cb) => cb(document));
            }),
            __classPrivateFieldGet(this, _DocumentService_documents, "f").onDidClose(({ document }) => {
                __classPrivateFieldGet(this, _DocumentService_connection, "f").console.log('close ' + document.original.uri);
                __classPrivateFieldGet(this, _DocumentService_onDocumentCloseCbs, "f").forEach((cb) => cb(document));
                document.session.disconnect();
            }),
            {
                dispose: () => {
                    __classPrivateFieldGet(this, _DocumentService_documents, "f").all().forEach((document) => document.session.disconnect());
                    __classPrivateFieldGet(this, _DocumentService_onDocumentOpenCbs, "f").length = 0;
                    __classPrivateFieldGet(this, _DocumentService_onDocumentCloseCbs, "f").length = 0;
                },
            },
        ];
        return {
            dispose() {
                disposables.forEach((disposable) => disposable.dispose());
            },
        };
    }
    get(uri) {
        return __classPrivateFieldGet(this, _DocumentService_documents, "f").get(uri);
    }
    onDidOpen(fn) {
        __classPrivateFieldGet(this, _DocumentService_onDocumentOpenCbs, "f").push(fn);
    }
    onDidClose(fn) {
        __classPrivateFieldGet(this, _DocumentService_onDocumentCloseCbs, "f").push(fn);
    }
};
_DocumentService_config = new WeakMap(), _DocumentService_connection = new WeakMap(), _DocumentService_capabilities = new WeakMap(), _DocumentService_documents = new WeakMap(), _DocumentService_onDocumentOpenCbs = new WeakMap(), _DocumentService_onDocumentCloseCbs = new WeakMap();
DocumentService = __decorate([
    inversify.injectable(),
    __param(0, inversify.inject(CONNECTION)),
    __param(1, inversify.inject(SERVER)),
    __param(2, inversify.inject(GRAMMARLY_SDK)),
    __param(3, inversify.inject(TEXT_DOCUMENTS_FACTORY)),
    __param(4, inversify.inject(CLIENT_INITIALIZATION_OPTIONS)),
    __metadata("design:paramtypes", [Object, Object, Function, Function, Object, ConfigurationService])
], DocumentService);
class GrammarlyDocument {
    constructor(original, createSession) {
        _GrammarlyDocument_instances.add(this);
        _GrammarlyDocument_context.set(this, null);
        this._isReady = null;
        this._isPaused = false;
        this.original = original;
        this.createSession = createSession;
    }
    get isPaused() {
        return this._isPaused;
    }
    pause() {
        this._isPaused = true;
    }
    resume() {
        this._isPaused = false;
        __classPrivateFieldGet(this, _GrammarlyDocument_instances, "m", _GrammarlyDocument_sync).call(this);
    }
    async isReady() {
        if (this._isReady != null)
            await this._isReady;
        if (this.session != null)
            return;
        this._isReady = (async () => {
            this.session = await this.createSession();
            await __classPrivateFieldGet(this, _GrammarlyDocument_instances, "m", _GrammarlyDocument_createTree).call(this);
            __classPrivateFieldGet(this, _GrammarlyDocument_instances, "m", _GrammarlyDocument_sync).call(this);
            this._isReady = null;
        })();
        await this._isReady;
    }
    findOriginalOffset(offset) {
        if (__classPrivateFieldGet(this, _GrammarlyDocument_context, "f") == null)
            return offset;
        const map = __classPrivateFieldGet(this, _GrammarlyDocument_context, "f").sourcemap;
        const index = binarySearchLowerBound(0, map.length - 1, (index) => map[index][1] < offset);
        const node = map[index];
        if (node == null)
            return 0;
        return node[0] + Math.max(0, offset - node[1]);
    }
    findOriginalRange(start, end) {
        return {
            start: this.original.positionAt(this.findOriginalOffset(start)),
            end: this.original.positionAt(this.findOriginalOffset(end)),
        };
    }
    toText(text) {
        var _a, _b;
        return (_b = (_a = __classPrivateFieldGet(this, _GrammarlyDocument_context, "f")) === null || _a === void 0 ? void 0 : _a.transformer.decode(text)) !== null && _b !== void 0 ? _b : text.ops.map((op) => op.insert).join('');
    }
    update(changes, version) {
        const context = __classPrivateFieldGet(this, _GrammarlyDocument_context, "f");
        if (context == null) {
            vscodeLanguageserverTextdocument.TextDocument.update(this.original, changes, version);
        }
        else if (changes.every((change) => 'range' in change)) {
            const _changes = changes;
            const offsets = _changes.map((change) => ({
                start: this.original.offsetAt(change.range.start),
                end: this.original.offsetAt(change.range.end),
            }));
            vscodeLanguageserverTextdocument.TextDocument.update(this.original, changes, version);
            _changes.forEach((change, index) => {
                const newEndIndex = offsets[index].start + change.text.length;
                const newEndPosition = this.original.positionAt(newEndIndex);
                context.tree.edit({
                    startIndex: offsets[index].start,
                    oldEndIndex: offsets[index].end,
                    newEndIndex: offsets[index].start + change.text.length,
                    startPosition: { row: change.range.start.line, column: change.range.start.character },
                    oldEndPosition: { row: change.range.end.line, column: change.range.end.character },
                    newEndPosition: { row: newEndPosition.line, column: newEndPosition.character },
                });
            });
            context.tree = context.parser.parse(this.original.getText(), context.tree);
        }
        else {
            vscodeLanguageserverTextdocument.TextDocument.update(this.original, changes, version);
            context.tree = context.parser.parse(this.original.getText());
        }
        __classPrivateFieldGet(this, _GrammarlyDocument_instances, "m", _GrammarlyDocument_sync).call(this);
    }
}
_GrammarlyDocument_context = new WeakMap(), _GrammarlyDocument_instances = new WeakSet(), _GrammarlyDocument_createTree = async function _GrammarlyDocument_createTree() {
    const language = this.original.languageId;
    switch (language) {
        case 'html':
        case 'markdown':
            const parser = await grammarlyRichtextEncoder.createParser(language);
            const transformer = grammarlyRichtextEncoder.transformers[language];
            const tree = parser.parse(this.original.getText());
            __classPrivateFieldSet(this, _GrammarlyDocument_context, { parser, tree, transformer, sourcemap: [] }, "f");
            break;
    }
}, _GrammarlyDocument_sync = function _GrammarlyDocument_sync() {
    if (this._isPaused)
        return;
    if (__classPrivateFieldGet(this, _GrammarlyDocument_context, "f") != null) {
        const [text, map] = __classPrivateFieldGet(this, _GrammarlyDocument_context, "f").transformer.encode(__classPrivateFieldGet(this, _GrammarlyDocument_context, "f").tree);
        this.session.setText(text);
        __classPrivateFieldGet(this, _GrammarlyDocument_context, "f").sourcemap = map;
    }
    else {
        this.session.setText({ ops: [{ insert: this.original.getText() }] });
    }
};
function binarySearchLowerBound(lo, hi, isValid) {
    while (lo < hi) {
        const mid = Math.ceil((hi + lo) / 2);
        if (isValid(mid)) {
            lo = mid;
        }
        else {
            hi = mid - 1;
        }
    }
    return hi;
}

var _DiagnosticsService_instances, _DiagnosticsService_connection, _DiagnosticsService_documents, _DiagnosticsService_diagnostics, _DiagnosticsService_setupDiagnostics, _DiagnosticsService_sendDiagnostics, _DiagnosticsService_clearDiagnostics, _DiagnosticsService_toDiagnostic;
let DiagnosticsService = class DiagnosticsService {
    constructor(connection, documents) {
        _DiagnosticsService_instances.add(this);
        _DiagnosticsService_connection.set(this, void 0);
        _DiagnosticsService_documents.set(this, void 0);
        _DiagnosticsService_diagnostics.set(this, void 0);
        __classPrivateFieldSet(this, _DiagnosticsService_connection, connection, "f");
        __classPrivateFieldSet(this, _DiagnosticsService_documents, documents, "f");
        __classPrivateFieldSet(this, _DiagnosticsService_diagnostics, new Map(), "f");
    }
    register() {
        __classPrivateFieldGet(this, _DiagnosticsService_documents, "f").onDidOpen((document) => __classPrivateFieldGet(this, _DiagnosticsService_instances, "m", _DiagnosticsService_setupDiagnostics).call(this, document));
        __classPrivateFieldGet(this, _DiagnosticsService_documents, "f").onDidClose((document) => __classPrivateFieldGet(this, _DiagnosticsService_instances, "m", _DiagnosticsService_clearDiagnostics).call(this, document));
        __classPrivateFieldGet(this, _DiagnosticsService_connection, "f").onRequest('$/pause', ([uri]) => {
            const document = __classPrivateFieldGet(this, _DiagnosticsService_documents, "f").get(uri);
            if (document == null)
                return;
            document.pause();
            __classPrivateFieldGet(this, _DiagnosticsService_instances, "m", _DiagnosticsService_sendDiagnostics).call(this, document);
        });
        __classPrivateFieldGet(this, _DiagnosticsService_connection, "f").onRequest('$/resume', ([uri]) => {
            const document = __classPrivateFieldGet(this, _DiagnosticsService_documents, "f").get(uri);
            if (document == null)
                return;
            document.resume();
            __classPrivateFieldGet(this, _DiagnosticsService_instances, "m", _DiagnosticsService_sendDiagnostics).call(this, document);
        });
        return { dispose() { } };
    }
    findSuggestionDiagnostics(document, range) {
        var _a;
        const diagnostics = [];
        const s = document.original.offsetAt(range.start);
        const e = document.original.offsetAt(range.end);
        (_a = __classPrivateFieldGet(this, _DiagnosticsService_diagnostics, "f").get(document.original.uri)) === null || _a === void 0 ? void 0 : _a.forEach((item) => {
            const start = document.original.offsetAt(item.diagnostic.range.start);
            const end = document.original.offsetAt(item.diagnostic.range.end);
            if (start <= e && s <= end)
                diagnostics.push(item);
        });
        return diagnostics;
    }
    getSuggestionDiagnostic(document, code) {
        var _a;
        return (_a = __classPrivateFieldGet(this, _DiagnosticsService_diagnostics, "f").get(document.original.uri)) === null || _a === void 0 ? void 0 : _a.get(code);
    }
};
_DiagnosticsService_connection = new WeakMap(), _DiagnosticsService_documents = new WeakMap(), _DiagnosticsService_diagnostics = new WeakMap(), _DiagnosticsService_instances = new WeakSet(), _DiagnosticsService_setupDiagnostics = function _DiagnosticsService_setupDiagnostics(document) {
    __classPrivateFieldGet(this, _DiagnosticsService_connection, "f").console.log(`${document.session.status} ${document.original.uri}`);
    const diagnostics = new Map();
    const sendDiagnostics = () => __classPrivateFieldGet(this, _DiagnosticsService_instances, "m", _DiagnosticsService_sendDiagnostics).call(this, document);
    __classPrivateFieldGet(this, _DiagnosticsService_diagnostics, "f").set(document.original.uri, diagnostics);
    document.session.addEventListener('suggestions', (event) => {
        event.detail.added.forEach((suggestion) => {
            diagnostics.set(suggestion.id, { suggestion, diagnostic: __classPrivateFieldGet(this, _DiagnosticsService_instances, "m", _DiagnosticsService_toDiagnostic).call(this, document, suggestion) });
        });
        event.detail.updated.forEach((suggestion) => {
            diagnostics.set(suggestion.id, { suggestion, diagnostic: __classPrivateFieldGet(this, _DiagnosticsService_instances, "m", _DiagnosticsService_toDiagnostic).call(this, document, suggestion) });
        });
        event.detail.removed.forEach((suggestion) => {
            diagnostics.delete(suggestion.id);
        });
        sendDiagnostics();
    });
    document.session.addEventListener('status', (event) => {
        __classPrivateFieldGet(this, _DiagnosticsService_connection, "f").console.log(`${event.detail} ${document.original.uri}`);
        __classPrivateFieldGet(this, _DiagnosticsService_connection, "f").sendNotification('$/onDocumentStatus', {
            uri: document.original.uri,
            status: event.detail,
        });
        switch (event.detail) {
            case 'idle':
                diagnostics.clear();
                document.session.suggestions.forEach((suggestion) => {
                    diagnostics.set(suggestion.id, { suggestion, diagnostic: __classPrivateFieldGet(this, _DiagnosticsService_instances, "m", _DiagnosticsService_toDiagnostic).call(this, document, suggestion) });
                });
                sendDiagnostics();
                break;
        }
    });
}, _DiagnosticsService_sendDiagnostics = function _DiagnosticsService_sendDiagnostics(document) {
    var _a;
    const diagnostics = (_a = __classPrivateFieldGet(this, _DiagnosticsService_diagnostics, "f").get(document.original.uri)) !== null && _a !== void 0 ? _a : new Map();
    __classPrivateFieldGet(this, _DiagnosticsService_connection, "f").sendDiagnostics({
        uri: document.original.uri,
        diagnostics: document.isPaused ? [] : Array.from(diagnostics.values()).map((item) => item.diagnostic),
    });
}, _DiagnosticsService_clearDiagnostics = function _DiagnosticsService_clearDiagnostics(document) {
    __classPrivateFieldGet(this, _DiagnosticsService_connection, "f").sendDiagnostics({
        uri: document.original.uri,
        version: document.original.version,
        diagnostics: [],
    });
}, _DiagnosticsService_toDiagnostic = function _DiagnosticsService_toDiagnostic(document, suggestion) {
    const highlight = suggestion.highlights[0];
    return {
        data: suggestion.id,
        message: suggestion.title,
        range: document.findOriginalRange(highlight.start, highlight.end),
        source: 'Grammarly',
        severity: suggestion.type === 'corrective' ? 1 : 3,
    };
};
DiagnosticsService = __decorate([
    inversify.injectable(),
    __param(0, inversify.inject(CONNECTION)),
    __metadata("design:paramtypes", [Object, DocumentService])
], DiagnosticsService);

var _CodeActionService_connection, _CodeActionService_capabilities, _CodeActionService_documents, _CodeActionService_diagnostics;
let CodeActionService = class CodeActionService {
    constructor(connection, capabilities, diagnostics, documents) {
        _CodeActionService_connection.set(this, void 0);
        _CodeActionService_capabilities.set(this, void 0);
        _CodeActionService_documents.set(this, void 0);
        _CodeActionService_diagnostics.set(this, void 0);
        __classPrivateFieldSet(this, _CodeActionService_connection, connection, "f");
        __classPrivateFieldSet(this, _CodeActionService_capabilities, capabilities, "f");
        __classPrivateFieldSet(this, _CodeActionService_diagnostics, diagnostics, "f");
        __classPrivateFieldSet(this, _CodeActionService_documents, documents, "f");
    }
    register() {
        __classPrivateFieldGet(this, _CodeActionService_capabilities, "f").codeActionProvider = {
            codeActionKinds: ['quickfix'],
            resolveProvider: true,
        };
        __classPrivateFieldGet(this, _CodeActionService_connection, "f").onCodeAction(async ({ textDocument, context }) => {
            const document = __classPrivateFieldGet(this, _CodeActionService_documents, "f").get(textDocument.uri);
            if (document == null)
                return [];
            return await Promise.all(context.diagnostics
                .map((diagnostic) => typeof diagnostic.data === 'string'
                ? __classPrivateFieldGet(this, _CodeActionService_diagnostics, "f").getSuggestionDiagnostic(document, diagnostic.data)
                : null)
                .filter((item) => item != null)
                .flatMap(({ suggestion, diagnostic }) => {
                const actions = suggestion.replacements.map((replacement) => {
                    return {
                        title: suggestion.title + (replacement.label != null ? ` — ${replacement.label}` : ''),
                        kind: 'quickfix',
                        diagnostics: [diagnostic],
                        data: {
                            uri: document.original.uri,
                            suggestionId: suggestion.id,
                            replacementId: replacement.id,
                        },
                    };
                });
                const dismiss = {
                    title: `Dismiss — ${suggestion.title}`,
                    kind: 'quickfix',
                    diagnostics: [diagnostic],
                    command: {
                        title: 'Dismiss suggestion',
                        command: 'grammarly.dismiss',
                        arguments: [
                            {
                                uri: document.original.uri,
                                suggestionId: suggestion.id,
                            },
                        ],
                    },
                };
                actions.push(dismiss);
                return actions;
            }));
        });
        __classPrivateFieldGet(this, _CodeActionService_connection, "f").onCodeActionResolve(async (codeAction) => {
            if (codeAction.data == null)
                return codeAction;
            const { uri, suggestionId, replacementId } = codeAction.data;
            const document = __classPrivateFieldGet(this, _CodeActionService_documents, "f").get(uri);
            if (document == null)
                return codeAction;
            const edit = await document.session.applySuggestion({
                suggestionId,
                replacementId,
            });
            __classPrivateFieldGet(this, _CodeActionService_connection, "f").console.log(JSON.stringify(edit, null, 2));
            const range = document.findOriginalRange(edit.range.start, edit.range.end);
            const newText = document.toText(edit.content);
            codeAction.edit = {
                changes: {
                    [uri]: [{ range, newText }],
                },
            };
            return codeAction;
        });
        return { dispose() { } };
    }
};
_CodeActionService_connection = new WeakMap(), _CodeActionService_capabilities = new WeakMap(), _CodeActionService_documents = new WeakMap(), _CodeActionService_diagnostics = new WeakMap();
CodeActionService = __decorate([
    inversify.injectable(),
    __param(0, inversify.inject(CONNECTION)),
    __param(1, inversify.inject(SERVER)),
    __metadata("design:paramtypes", [Object, Object, DiagnosticsService,
        DocumentService])
], CodeActionService);

function encodeLeadingAndTrailingSpace(text) {
    return text.replace(/^\n+|\n+$/, '').replace(/^[ ]+|[ ]+$/g, (m) => '&nbsp;'.repeat(m.length));
}
function toMarkdown(markup) {
    let indent = 0;
    function stringify(node) {
        if (typeof node === 'string')
            return node + '\n';
        const children = [];
        node.children.forEach((child) => {
            if (typeof child !== 'string' && ['del', 'em', 'strong'].includes(child.type) && children.length > 0) {
                const last = children[children.length - 1];
                if (typeof last !== 'string' && last.type === child.type) {
                    last.children.push(...child.children);
                }
            }
            if (typeof child === 'string') {
                children.push(child);
            }
            else {
                children.push({ type: child.type, children: child.children.slice() });
            }
        });
        switch (node.type) {
            case 'ul':
                try {
                    indent += 2;
                    return `${processChildren(node.children)}\n`;
                }
                finally {
                    indent -= 2;
                }
            case 'li':
                return ' '.repeat(indent - 2) + `- ${processChildren(node.children)}\n`;
            case 'del':
                return `<span style="color:#F00;">~~${encodeLeadingAndTrailingSpace(processChildren(node.children))}~~</span>\n`;
            case 'em':
                return `_${encodeLeadingAndTrailingSpace(processChildren(node.children))}_\n`;
            case 'strong':
                return `**${encodeLeadingAndTrailingSpace(processChildren(node.children))}**\n`;
            case 'ins':
                return `<span style="color:#0F0;">${processChildren(node.children)}</span>\n`;
            default:
                return processChildren(node.children);
        }
    }
    return processChildren(markup);
    function processChildren(nodes) {
        return nodes.map((node) => stringify(node)).join('');
    }
}

var _HoverService_connection, _HoverService_capabilities, _HoverService_documents, _HoverService_diagnostics;
let HoverService = class HoverService {
    constructor(connection, capabilities, diagnostics, documents) {
        _HoverService_connection.set(this, void 0);
        _HoverService_capabilities.set(this, void 0);
        _HoverService_documents.set(this, void 0);
        _HoverService_diagnostics.set(this, void 0);
        __classPrivateFieldSet(this, _HoverService_connection, connection, "f");
        __classPrivateFieldSet(this, _HoverService_capabilities, capabilities, "f");
        __classPrivateFieldSet(this, _HoverService_diagnostics, diagnostics, "f");
        __classPrivateFieldSet(this, _HoverService_documents, documents, "f");
    }
    register() {
        __classPrivateFieldGet(this, _HoverService_capabilities, "f").hoverProvider = true;
        __classPrivateFieldGet(this, _HoverService_connection, "f").onHover(async ({ textDocument, position }) => {
            const document = __classPrivateFieldGet(this, _HoverService_documents, "f").get(textDocument.uri);
            if (document == null)
                return null;
            const diagnostics = __classPrivateFieldGet(this, _HoverService_diagnostics, "f").findSuggestionDiagnostics(document, { start: position, end: position });
            diagnostics.sort((a, b) => b.suggestion.highlights[0].start - a.suggestion.highlights[0].start);
            const diagnostic = diagnostics[0];
            if (diagnostic == null)
                return null;
            const contents = `**${diagnostic.suggestion.title.trim()}**\n\n${toMarkdown(diagnostic.suggestion.description).trim()}\n\n\n${diagnostic.suggestion.replacements.length === 1
                ? `… ${toMarkdown(diagnostic.suggestion.replacements[0].preview).trim()} …`
                : diagnostic.suggestion.replacements
                    .map((replacement) => `1. … ${toMarkdown(replacement.preview).trim()} …\n`)
                    .join('')}`;
            return {
                range: diagnostic.diagnostic.range,
                contents: {
                    kind: 'markdown',
                    value: contents,
                },
            };
        });
        return { dispose() { } };
    }
};
_HoverService_connection = new WeakMap(), _HoverService_capabilities = new WeakMap(), _HoverService_documents = new WeakMap(), _HoverService_diagnostics = new WeakMap();
HoverService = __decorate([
    inversify.injectable(),
    __param(0, inversify.inject(CONNECTION)),
    __param(1, inversify.inject(SERVER)),
    __metadata("design:paramtypes", [Object, Object, DiagnosticsService,
        DocumentService])
], HoverService);

function createLanguageServer({ getConnection, createTextDocuments, init, pathEnvironmentForSDK, }) {
    return () => {
        const disposables = [];
        const capabilities = {};
        const container = new inversify.Container({
            autoBindInjectable: true,
            defaultScope: 'Singleton',
        });
        const connection = getConnection();
        container.bind(CONNECTION).toConstantValue(connection);
        container.bind(SERVER).toConstantValue(capabilities);
        connection.onInitialize(async (params) => {
            const options = params.initializationOptions;
            if ((options === null || options === void 0 ? void 0 : options.clientId) == null)
                throw new Error('clientId is required');
            await pathEnvironmentForSDK(options.clientId);
            const sdk = await init(options.clientId);
            container.bind(CLIENT).toConstantValue(params.capabilities);
            container.bind(CLIENT_INFO).toConstantValue({ ...params.clientInfo, id: options.clientId });
            container.bind(CLIENT_INITIALIZATION_OPTIONS).toConstantValue(options);
            container.bind(GRAMMARLY_SDK).toConstantValue(sdk);
            container.bind(TEXT_DOCUMENTS_FACTORY).toConstantValue(createTextDocuments);
            disposables.push(container.get(ConfigurationService).register(), container.get(DocumentService).register(), container.get(DiagnosticsService).register(), container.get(HoverService).register(), container.get(CodeActionService).register());
            connection.onRequest('$/handleOAuthCallbackUri', async (url) => {
                await sdk.handleOAuthCallback(url);
            });
            connection.onRequest('$/isUserAccountConnected', async () => {
                return sdk.isUserAccountConnected;
            });
            connection.onRequest('$/getOAuthUrl', async (oauthRedirectUri) => {
                try {
                    return await sdk.getOAuthUrl(oauthRedirectUri);
                }
                catch (error) {
                    console.error(error);
                    throw error;
                }
            });
            connection.onRequest('$/logout', async () => {
                await sdk.logout();
            });
            sdk.addEventListener('isUserAccountConnected', () => {
                connection.sendNotification('$/onUserAccountConnectedChange', {
                    isUserAccountConnected: sdk.isUserAccountConnected,
                });
            });
            connection.console.log('Initialized!');
            return {
                serverInfo: {
                    name: 'Grammarly',
                },
                capabilities,
            };
        });
        connection.onExit(() => {
            disposables.forEach((disposable) => disposable.dispose());
        });
        connection.listen();
        connection.console.log('Ready!');
    };
}

class FileStorage {
    constructor(directory) {
        this.directory = directory;
        node_fs.mkdirSync(directory, { recursive: true });
    }
    getItem(key) {
        try {
            return node_fs.readFileSync(node_path.resolve(this.directory, key), 'utf-8');
        }
        catch {
            return null;
        }
    }
    setItem(key, value) {
        node_fs.writeFileSync(node_path.resolve(this.directory, key), value);
    }
    removeItem(key) {
        node_fs.rmSync(node_path.resolve(this.directory, key), { force: true });
    }
    clear() {
        node_fs.rmSync(this.directory, { force: true, recursive: true });
        node_fs.mkdirSync(this.directory, { recursive: true });
    }
    key(index) {
        return node_fs.readdirSync(this.directory)[index];
    }
    get length() {
        return node_fs.readdirSync(this.directory).length;
    }
}

function getConnection() {
    return node.createConnection(node.ProposedFeatures.all);
}
function createTextDocuments(config) {
    return new node.TextDocuments(config);
}
function pathEnvironmentForSDK(clientId) {
    globalThis.localStorage = new FileStorage(node_path.resolve(node_os.homedir(), '.config', 'grammarly-languageserver', clientId));
}
const startLanguageServer = createLanguageServer({
    getConnection,
    createTextDocuments,
    init: sdk.init,
    pathEnvironmentForSDK,
});

exports.startLanguageServer = startLanguageServer;
//# sourceMappingURL=index.node.cjs.map
